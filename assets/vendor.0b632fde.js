const V="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvxyzw0123456789_-",I=6,ht=t=>t.split("").reverse().map(s=>{const e=V.indexOf(s);if(e===-1)throw new Error(`Invalid clip string character ${s}`);return e.toString(2).padStart(I,"0")}).join(""),Tt=t=>{for(const s of t)if(s!=="0"&&s!=="1")throw new Error(`Invalid bit character ${s}`);if(t.length%I!=0)throw new Error(`Bit string length (${t.length}) must be a multiple of ${I}`);return Array(t.length/I).fill().map((s,e)=>{const r=t.slice(e*I,(e+1)*I),n=parseInt(r,2);return V[n]}).reverse().join("")};var O={clipToBits:ht,bitsToClip:Tt,BITS_PER_CHAR:I};const{BITS_PER_CHAR:R}=O,W=t=>t.replace(/[^01]/g,""),gt=t=>t.replace(/[^A-Za-z0-9_\-]/g,""),dt=t=>{const s=W(t),e=(R-s.length%R)%R;return e>0?Array(e).fill().map(n=>"0").join("")+t:t},xt=t=>{const s=t.indexOf("1");return s===-1?"":t.slice(s)},$t=(t,s)=>Object.entries(t).map(s).reduce((e,[r,n])=>Object.assign(e,{[r]:n}),{}),yt=(t,s)=>Object.entries(t).filter(s).reduce((e,[r,n])=>Object.assign(e,{[r]:n}),{});var D={cleanBits:W,cleanClip:gt,padInputBits:dt,removePadding:xt,omap:$t,ofilter:yt};const Et=-1,It=15,Bt=15,ut=15,_t=255,vt=0;var X={EMPTY_TYPE:Et,GROUND_TYPE:It,MAX_TYPE_COUNT:Bt,MAX_TYPE:ut,MAX_HEIGHT:_t,GROUND_HEIGHT:vt};const{removePadding:wt}=D,{BITS_PER_CHAR:b}=O,{MAX_HEIGHT:S,MAX_TYPE_COUNT:L,MAX_TYPE:w,EMPTY_TYPE:U}=X,mt=/[^01]/;class Pt{constructor(s){this.bits=s,this.cursor=0}read(s,e=!1){if(s===0)throw new Error("Trying to read zero bytes");if(this.remaining<s&&!e)throw new Error(`Could not read ${s} bits (only ${this.remaining} remaining) at position ${this.cursor}`);const r=this.bits.slice(-this.cursor-s,this.cursor>0?-this.cursor:void 0);return this.cursor+=s,r.length===0?0:parseInt(r,2)}get remaining(){return this.bits.length-this.cursor}}const q=t=>1<<t-1,K=t=>(1<<t)-1,u=t=>Math.ceil(Math.log2(t+1)),Ot=(t,s)=>{if(t===0&&s===0)return 0;const e=Math.max(t<0?Math.abs(t):t+1,s<0?Math.abs(s):s+1);return u(e*2-1)},Q=t=>{const s=u(t+1),e=K(s);return{typeIndexBitLength:s,typeStopIndex:e}},_=5,tt=u(L-1),et=u(w),M=1,Dt=t=>{const s=t.match(mt);if(s!==null)throw new Error(`Invalid bit character ${s[0]}`);if(t.length%b!=0)throw new Error(`Bit string length (${t.length}) must be a multiple of 6`);const e={},r=new Pt(wt(t)),n=r.read(_),i=r.read(_),o=r.read(_);if(n>0){const c=q(n);e.xInitial=r.read(n)-c,e.yInitial=r.read(n)-c}else e.xInitial=0,e.yInitial=0;const a=r.read(tt);e.types=Array(a).fill().map(c=>{const $=r.read(et);if($>w)throw new Error(`Invalid voxel type ${$}, max ${w} near bit ${r.cursor}`);return $});const{typeIndexBitLength:f,typeStopIndex:h}=Q(a);e.corners=[];let d=e.xInitial,x=!0;for(;r.remaining>0;){const c={};for(x?(c.xDelta=null,x=!1):Boolean(r.read(M))&&i>0?(c.xDelta=r.read(i),d+=c.xDelta):c.xDelta=0,o>0?c.yOffset=r.read(o):c.yOffset=0,c.hasGround=Boolean(r.read(M)),c.voxels=[];c.voxels.length<S;){const y=r.read(f,!0);if(y===h)break;const E=y-1;if(E<U||E>=a){const N=e.yInitial+c.yOffset;throw new Error(`Invalid voxel type ${E}/${a} at (${d}, ${N}, ${c.voxels.length+1}) near bit ${r.cursor}`)}c.voxels.push(E)}const $=c.voxels.filter(y=>y!==U);(c.hasGround||$.length>0)&&e.corners.push(c)}return e},g=(t,s)=>{if(t<0)throw new Error(`Trying to get bits for negative value ${t}`);const e=K(s);if(t>e)throw new Error(`Trying to get bits for too large value ${t} (max ${e})`);return t.toString(2).padStart(s,"0")},B=t=>t.toString().replace(/0/g,"O").replace(/1/g,"l"),bt=(t,s={})=>{const{pretty:e=!1,pad:r=!0}=s;let n="",i="";const o=Ot(Math.min(t.xInitial,t.yInitial),Math.max(t.xInitial,t.yInitial));let a=0,f=0;for(const l of t.corners)a=Math.max(a,l.xDelta),f=Math.max(f,l.yOffset);const h=u(a),d=u(f),x=g(o,_),c=g(h,_),$=g(d,_);if(n=$+c+x+n,e&&(i=`<+y=${$}[${B(d)}] dx=${c}[${B(h)}] po=${x}[${B(o)}]>`+i),o>0){const l=q(o),T=g(t.xInitial+l,o),p=g(t.yInitial+l,o);n=p+T+n,e&&(i=`<y=${p}[${B(t.yInitial)}] x=${T}[${B(t.xInitial)}]> `+i)}if(t.types.length>L)throw new Error(`Invalid types.length ${t.types.length}, max ${L}`);const y=g(t.types.length,tt);n=y+n,e&&(i=`(${y})> `+i);for(const l of t.types){if(l<0||l>w)throw new Error(`Invalid type ${l}, max ${w}`);const T=g(l,et);n=T+n,e&&(i=`${T} `+i)}e&&(i="<"+i);const{typeIndexBitLength:E,typeStopIndex:N}=Q(t.types.length),z=t.corners.filter((l,T)=>T===0||l.hasGround||l.voxels.length>0),pt=z.length>0?z:[{xDelta:null,hasGround:!1,voxels:[]}];let J=!0;for(const l of pt){if(e&&(i="| "+i),J){if(l.xDelta!==null)throw new Error("xDelta on first corner");J=!1}else{const p=g(l.xDelta?1:0,M);if(n=p+n,e&&(i=`(dx?${p}) `+i),l.xDelta){const v=g(l.xDelta,h);n=v+n,e&&(i=`(dx${v}[${B(l.xDelta)}]) `+i)}}if(d>0){const p=g(l.yOffset,d);n=p+n,e&&(i=`(+y${p}[${B(l.yOffset)}]) `+i)}const T=g(l.hasGround?1:0,M);if(n=T+n,e&&(i=`(g?${T}) `+i),l.voxels.length>S)throw new Error(`Too many voxels (${l.voxels.length}), max ${S}`);for(const p of l.voxels){if(p<U||p>=t.types.length)throw new Error(`Invalid type ${p}, min 0, max ${t.types.length}`);const v=g(p+1,E);n=v+n,e&&(i=`${v} `+i)}if(l.voxels.length<S){const p=g(N,E);n=p+n,e&&(i=`${p} `+i)}}if(r){const l=(b-n.length%b)%b;if(l>0){const T=Array(l).fill().map(p=>"0").join("");n=T+n,e&&(i=`<${T}> | `+i)}}return e?i:n};var st={bitsToDense:Dt,denseToBits:bt};const{EMPTY_TYPE:A,GROUND_TYPE:m,MAX_TYPE_COUNT:Y,GROUND_HEIGHT:P,MAX_HEIGHT:G,MAX_TYPE:nt}=X,{ofilter:St}=D,Mt=t=>{if(t.types.length>Y)throw new Error(`Too many types (${t.types.length}), max ${Y}`);if(t.corners[0].xDelta!==null)throw new Error(`First xDelta (${t.corners[0].xDelta}) is not null`);const s=[];let e=t.xInitial;for(const r of t.corners){r.xDelta&&(e+=r.xDelta);const n=t.yInitial+(r.yOffset||0),i={};if(r.hasGround&&(i[P]=m),r.voxels.length>G)throw new Error(`Too many voxels (${r.voxels.length}), max ${G}`);for(let o=0;o<r.voxels.length;o++){const a=r.voxels[o];if(a!==A){if(!Number.isInteger(a))throw new Error(`Invalid voxel type ${a} at (${e}, ${n}, ${o+1})`);if(a<A||a>=t.types.length)throw new Error(`Invalid voxel type ${a} at (${e}, ${n}, ${o+1}), min ${A}, max ${t.types.length-1}`);i[o+(P+1)]=t.types[a]}}Object.keys(i).length>0&&s.push({x:e,y:n,voxels:i})}return s},At=t=>{const s={},e=t.map(o=>{const a=o.voxels[P];if(a!==void 0&&a!==m)throw new Error(`Trying to set voxel type ${o.voxels[0]} on ground, only ${m} allowed`);return{x:o.x,y:o.y,hasGround:a===m,voxels:St(o.voxels,([f,h])=>h!==void 0)}}).filter(o=>o.hasGround||Object.keys(o.voxels).length>0).sort((o,a)=>o.x<a.x?-1:o.x>a.x?1:o.y<a.y?-1:o.y>a.y?1:0);if(e.length===0)return{xInitial:0,yInitial:0,types:[],corners:[]};let r=1/0;const n=[];for(const o of e){r=Math.min(r,o.y);for(const[a,f]of Object.entries(o.voxels)){if(f===void 0)continue;const h=Number(a);if(h.toString()!==a||!Number.isInteger(h))throw new Error(`Voxel height ${a} is not an integer`);if(h>G)throw new Error(`Invalid height ${h}, max ${G}`);if(!Number.isInteger(f))throw new Error(`Voxel type ${f} is not an index`);if(f<0||f>nt)throw new Error(`Invalid voxel type ${f}, min 0, max ${nt}`);!n.includes(f)&&(h!==P||f!==m)&&n.push(f)}}if(n.length>Y)throw new Error(`Too many types (${n.length}), max ${Y}`);s.xInitial=e[0].x,s.yInitial=r,s.types=n.sort((o,a)=>o<a?-1:o>a?1:0),s.corners=[];let i=s.xInitial;for(const o of e){const a=s.corners.length!==0?o.x-i:null;i=o.x;const f=o.y-s.yInitial,h=Math.max(...Object.keys(o.voxels)),d=[];for(let x=P+1;x<=h;x++){const c=o.voxels[x];c===void 0?d.push(A):d.push(n.indexOf(c))}s.corners.push({xDelta:a,yOffset:f,hasGround:o.hasGround,voxels:d})}return s};var ot={denseToSparse:Mt,sparseToDense:At};const{clipToBits:rt,bitsToClip:j}=O,{bitsToDense:C,denseToBits:H}=st,{denseToSparse:k,sparseToDense:it}=ot,{cleanBits:Yt,cleanClip:Gt,padInputBits:Ct,removePadding:Ht}=D,Z=t=>C(rt(t)),at=t=>j(H(t)),lt=t=>k(C(t)),F=(t,s)=>H(it(t),s),ct=t=>j(F(t)),ft=t=>k(Z(t)),Nt={clip:{bits:rt,dense:Z,sparse:ft},bits:{clip:j,dense:C,sparse:lt},dense:{clip:at,bits:H,sparse:k},sparse:{clip:ct,bits:F,dense:it}},Rt=(t,s,e,r={})=>{const{pretty:n=!1,keepPadding:i=!1,strictInPadding:o=!1,strictInAlphabet:a=!1}=r;switch(t){case"clip":{a?e=e.trim():e=Gt(e);break}case"bits":{a?e=e.trim():e=Yt(e),o||(e=Ct(e));break}case"dense":case"sparse":{e=JSON.parse(e);break}default:throw new Error("Unreachable")}const f=Nt[t][s];switch(f&&(e=f(e)),s){case"clip":return e;case"bits":return n?(e=C(e),e=H(e,{pretty:!0,pad:i}),`"${e}"`):i?e:Ht(e);case"dense":case"sparse":return JSON.stringify(e,null,n?2:void 0);default:throw new Error("Unreachable")}};var Xt={clipToDense:Z,denseToClip:at,bitsToSparse:lt,sparseToBits:F,sparseToClip:ct,clipToSparse:ft,convertToString:Rt};const{clipToBits:Lt,bitsToClip:Ut,BITS_PER_CHAR:jt}=O,{bitsToDense:kt,denseToBits:Zt}=st,{denseToSparse:Ft,sparseToDense:zt}=ot,{clipToDense:Jt,denseToClip:Vt,bitsToSparse:Wt,sparseToBits:qt,sparseToClip:Kt,clipToSparse:Qt,convertToString:te}=Xt,{cleanBits:ee,cleanClip:se,padInputBits:ne,removePadding:oe}=D,{EMPTY_TYPE:re,GROUND_TYPE:ie,MAX_TYPE_COUNT:ae,MAX_TYPE:le,MAX_HEIGHT:ce}=X;var fe={clipToBits:Lt,bitsToClip:Ut,BITS_PER_CHAR:jt,bitsToDense:kt,denseToBits:Zt,denseToSparse:Ft,sparseToDense:zt,clipToDense:Jt,denseToClip:Vt,bitsToSparse:Wt,sparseToBits:qt,sparseToClip:Kt,clipToSparse:Qt,convertToString:te,cleanBits:ee,cleanClip:se,padInputBits:ne,removePadding:oe,EMPTY_TYPE:re,GROUND_TYPE:ie,MAX_TYPE_COUNT:ae,MAX_TYPE:le,MAX_HEIGHT:ce};export{fe as l};
